import gudhi as gd
import numpy as np
import vectorization as vec

from gudhi import bottleneck_distance
from gudhi.wasserstein import wasserstein_distance
from tsph import lp_distance
from tda_divergence import tda_divergence


class TimeSeriesPersistence:
    """
    Class to generate and manage persistence diagram based representations of time series.

    Static methods provide vector representations of the diagrams generated by this class.
    """

    def __init__(self, time_series: np.array) -> None:
        self._time_series = time_series
        self._sublevel_diagram = None
        self._superlevel_diagram = None
        self._vector_persistence_statistics = None

    @property
    def sublevel_diagram(self):
        if self._sublevel_diagram is None:
            self._sublevel_diagram = (
                TimeSeriesPersistence._persistence_diagram_from_time_series(
                    self._time_series, superlevel_filtration=False
                )
            )
        return self._sublevel_diagram

    @property
    def superlevel_diagram(self):
        if self._superlevel_diagram is None:
            self._superlevel_diagram = (
                TimeSeriesPersistence._persistence_diagram_from_time_series(
                    self._time_series, superlevel_filtration=True
                )
            )
        return self._superlevel_diagram

    @property
    def superlevel_diagram_flipped(self):
        return TimeSeriesPersistence._flip_super_and_sub_level_persistence_points(
            self.superlevel_diagram
        )

    @staticmethod
    def _sublevel_set_filtration(time_series):
        """
        Helper function. Creates the sublevel set filtration for the given time series.

        Parameters
        ----------
        time_series : array_like
            A list or numpy array of the input time series.

        Returns
        -------
        list
            The filtration: a list of (simplex, value) pairs representing the simplices in the sublevel set filtration.
        """

        filtration = []
        n = len(time_series)

        for i in range(n):
            filtration.append(([i], time_series[i]))

            if i < n - 1:
                edge_value = max(time_series[i], time_series[i + 1])
                filtration.append(([i, i + 1], edge_value))

        return filtration

    @staticmethod
    def _superlevel_set_filtration(time_series):
        """
        Helper function. Creates the superlevel set filtration for the given time series.

        Parameters
        ----------
        time_series : array_like
            A list or numpy array of the input time series.

        Returns
        -------
        list
            The filtration: a list of (simplex, value) pairs representing the superlevel set filtration.

        Notes
        -----
        The values of the simplices are the negations of the original time series values,
        to ensure they are increasing over the filtration.
        """

        # invert the sequence (make peaks into pits and vice versa)
        time_series = -1 * np.array(time_series)

        # apply the sublevel algorithm to the inverted sequence
        return TimeSeriesPersistence._sublevel_set_filtration(time_series)

    @staticmethod
    def _persistent_homology_simplex_tree(filtration):
        """
        Helper function. Construct a Gudhi simplex tree representing the given filtration.

        Parameters
        ----------
        filtration : list
            List of (simplex, value) tuples in the filtration

        Returns
        -------
        gudhi.SimplexTree
            A Gudhi SimplexTree object
        """

        # Create a simplex tree object
        st = gd.SimplexTree()

        # Insert the filtration into the simplex tree
        for simplex, value in filtration:
            st.insert(simplex, value)

        return st

    @staticmethod
    def _persistence_diagram_from_simplex_tree(
        simplex_tree, dimension=0, superlevel_filtration=False
    ):
        """
        Helper function. Construct the persistent homology diagram induced by the given simplex tree.

        Parameters
        ----------
        simplex_tree : a Gudhi SimplexTree object
        dimension : integer, optional
            The dimension of the homology features to be returned.
        superlevel_filtration : Boolean, optional
            Does the simplex tree arise from a superlevel set filtration?
            Default is `False` implying we have a sublevel set simplex tree.

        Returns
        -------
        list
            The persistence diagram: a list of the persistent homology (birth, death) pairs in the given dimension.

        Notes
        -----
        1. When superlevel set adjustment is applied by setting `superlevel_filtration=True`, the intervals returned are (-birth, -death) rather than (birth, death). This is to account for decreasing function values used when building a superlevel set filtration, and the assumption that a simplex tree corresponding to a superlevel set filtration on `f(x)` has been built using the sublevel set filtration of the negated function `-f(x)`. Note that in this situation critical values will satisfy `death<birth`.
        2. The infinite point (corresponding to the global minimum) is removed from the resulting set of points, to ensure downstream functions such as entropy always have finite data to work with.
        """

        if not (dimension >= 0):
            raise ValueError("Requested homology dimension out of range")

        simplex_tree.compute_persistence()
        persistence_diagram = simplex_tree.persistence_intervals_in_dimension(dimension)

        # remove nonfinite points
        persistence_diagram = [
            (b, d)
            for (b, d) in persistence_diagram
            if np.isfinite(b) and np.isfinite(d)
        ]

        # reflip the axes if the filtration was built with superlevels
        if superlevel_filtration:
            persistence_diagram = [(-b, -d) for (b, d) in persistence_diagram]

        # finally create a 2-d numpy array for downstream processing
        persistence_diagram = np.array(persistence_diagram)

        return persistence_diagram

    @staticmethod
    def _flip_super_and_sub_level_persistence_points(persistence_diagram):
        """
        Helper function. Reflect the points in a persistence diagram across the birth=death diagonal.

        Parameters
        ----------
        persistence_diagram : list
            A list of the persistent homology (birth, death) intervals in the given dimension.

        Returns
        -------
        list
            A list of the persistent homology (death, birth) intervals in the given dimension.

        Notes
        -----
        Use this function to make superlevel and sublevel set persistence diagrams comparable using
        standard persistence diagram metrics.
        """

        return np.array([(d, b) for (b, d) in persistence_diagram])

    @staticmethod
    def _persistence_diagram_from_time_series(time_series, superlevel_filtration=False):
        """
        Helper function. Persistence diagram of piecewise linear interpolation of time series.

        Parameters
        ----------
        time_series : array_like
            The discrete time series over which to compute persistent homology.
        superlevel_filtration : boolean, optional
            Is this diagram for a superlevel set filtration? Default: sublevel set filtration.

        Returns
        -------
        array
            List of finite (b,d) pairs in the given diagram.
        """

        filter_function = (
            TimeSeriesPersistence._superlevel_set_filtration
            if superlevel_filtration
            else TimeSeriesPersistence._sublevel_set_filtration
        )
        filtration = filter_function(time_series)
        simplex_tree = TimeSeriesPersistence._persistent_homology_simplex_tree(
            filtration
        )
        persistence_diagram = (
            TimeSeriesPersistence._persistence_diagram_from_simplex_tree(
                simplex_tree, superlevel_filtration=superlevel_filtration
            )
        )

        return persistence_diagram

    ############################################
    ## Vectorisations of persistence diagrams ##
    ############################################

    @staticmethod
    def persistence_statistics_vector(persistence_diagram):
        return vec.GetPersStats(persistence_diagram)

    def persistence_statistics_vector_sub(self):
        return TimeSeriesPersistence.persistence_statistics_vector(
            self.sublevel_diagram
        )

    def persistence_statistics_vector_sup(self):
        return TimeSeriesPersistence.persistence_statistics_vector(
            self.superlevel_diagram_flipped
        )

    def persistence_statistics_vector_full(self):
        return np.concatenate(
            self.persistence_statistics_vector_sub(),
            self.persistence_statistics_vector_sup(),
        )

    @staticmethod
    def entropy_summary_function(persistence_diagram, resolution=100):
        return vec.GetEntropySummary(persistence_diagram, res=resolution)

    def entropy_summary_function_sub(self, resolution=100):
        return TimeSeriesPersistence.entropy_summary_function(
            self.sublevel_diagram, resolution=resolution
        )

    def entropy_summary_function_sup(self, resolution=100):
        return TimeSeriesPersistence.entropy_summary_function(
            self.superlevel_diagram_flipped, resolution=resolution
        )

    def entropy_summary_function_full(self, resolution=100):
        return np.concatenate(
            self.entropy_summary_function_sub(resolution=resolution),
            self.entropy_summary_function_sup(resolution=resolution),
        )

    @staticmethod
    def betti_curve_function(persistence_diagram, resolution=100):
        return vec.GetBettiCurveFeature(persistence_diagram, res=resolution)

    def betti_curve_function_sub(self, resolution=100):
        return TimeSeriesPersistence.betti_curve_function(
            self.sublevel_diagram, resolution=resolution
        )

    def betti_curve_function_sup(self, resolution=100):
        return TimeSeriesPersistence.betti_curve_function(
            self.superlevel_diagram_flipped, resolution=resolution
        )

    def betti_curve_function_full(self, resolution=100):
        return np.concatenate(
            self.betti_curve_function_sub(resolution=resolution),
            self.betti_curve_function_sup(resolution=resolution),
        )

    @staticmethod
    def persistence_silhouette_function(persistence_diagram, resolution=100, w=1):
        return vec.GetPersSilhouetteFeature(persistence_diagram, res=resolution, w=w)

    def persistence_silhouette_function_sub(self, resolution=100, w=1):
        return TimeSeriesPersistence.persistence_silhouette_function(
            self.sublevel_diagram, resolution=resolution, w=w
        )

    def persistence_silhouette_function_sup(self, resolution=100, w=1):
        return TimeSeriesPersistence.persistence_silhouette_function(
            self.superlevel_diagram_flipped, resolution=resolution, w=w
        )

    def persistence_silhouette_function_full(self, resolution=100, w=1):
        return np.concatenate(
            self.persistence_silhouette_function_sub(resolution=resolution, w=w),
            self.persistence_silhouette_function_sup(resolution=resolution, w=w),
        )

    @staticmethod
    def persistence_lifespan_curve_function(persistence_diagram, resolution=100):
        return vec.GetPersLifespanFeature(persistence_diagram, res=resolution)

    def persistence_lifespan_curve_function_sub(self, resolution=100):
        return TimeSeriesPersistence.persistence_lifespan_curve_function(
            self.sublevel_diagram, resolution=resolution
        )

    def persistence_lifespan_curve_function_sup(self, resolution=100):
        return TimeSeriesPersistence.persistence_lifespan_curve_function(
            self.superlevel_diagram_flipped, resolution=resolution
        )

    def persistence_lifespan_curve_function_full(self, resolution=100):
        return np.concatenate(
            self.persistence_lifespan_curve_function_sub(resolution=resolution),
            self.persistence_lifespan_curve_function_sup(resolution=resolution),
        )

    @staticmethod
    def persistence_image(persistence_diagram, bandwidth=0.2, resolution=20):
        return vec.GetPersImageFeature(persistence_diagram, bw=bandwidth, r=resolution)

    def persistence_image_sub(self, bandwidth=0.2, resolution=20):
        return TimeSeriesPersistence.persistence_image(
            self.sublevel_diagram, bandwidth=bandwidth, resolution=resolution
        )

    def persistence_image_sup(self, bandwidth=0.2, resolution=20):
        return TimeSeriesPersistence.persistence_image(
            self.superlevel_diagram_flipped, bandwidth=bandwidth, resolution=resolution
        )

    def persistence_image_full(self, bandwidth=0.2, resolution=20):
        return np.concatenate(
            self.persistence_image_sub(bandwidth=bandwidth, resolution=resolution),
            self.persistence_image_sup(bandwidth=bandwidth, resolution=resolution),
        )


    ####################################################################
    ## Divergences of super and sub level persistence representations ##
    ####################################################################

    def entropy_summary_divergence(self, resolution=100, p=2.0):
        """
        Distance between persistence entropy summaries.
        """

        f1 = TimeSeriesPersistence.entropy_summary_function(
            self.sublevel_diagram, resolution=resolution
        )
        f2 = TimeSeriesPersistence.entropy_summary_function(
            self.superlevel_diagram_flipped, resolution=resolution
        )
        return lp_distance(f1, f2, p=p)

    def stats_divergence(self, p=2.0):
        """
        Vector-based distance between persistence statistics vector summaries.
        """
        v1 = TimeSeriesPersistence.persistence_statistics_vector(self.sublevel_diagram)
        v2 = TimeSeriesPersistence.persistence_statistics_vector(
            self.superlevel_diagram_flipped
        )
        return lp_distance(v1, v2, p=p)

    def bottleneck_divergence(self):
        """
        Bottleneck distance between sublevel and superlevel persistence diagrams.
        """
        return bottleneck_distance(
            self.sublevel_diagram, self.superlevel_diagram_flipped
        )

    def wasserstein_divergence(self, p=1.0):
        """
        p-Wasserstein distance between sublevel and superlevel persistence diagrams.
        """
        return wasserstein_distance(
            self.sublevel_diagram, self.superlevel_diagram_flipped, order=p
        )
