import gudhi as gd
import numpy as np
import vectorization as vec

from numpy.linalg import norm
from teaspoon.TDA.PHN import point_summaries
from gudhi import bottleneck_distance
from gudhi.wasserstein import wasserstein_distance
from scipy.stats import wasserstein_distance as earth_movers_distance


class EmptyDiagramException(Exception):
    pass


class TimeSeriesPersistence:
    """
    Generate and manage persistence diagram representations of time series.

    Properties include vector representations and divergences of the diagrams
    and vectors generated by this class.
    """

    def __init__(
        self,
        time_series: np.array,
        ENTROPY_SUMMARY_RESOLUTION=100,
        BETTI_CURVE_RESOLUTION=100,
        BETTI_CURVE_NORM_P_VALUE=1.0,
        SILHOUETTE_RESOLUTION=100,
        SILHOUETTE_WEIGHT=1,
        LIFESPAN_CURVE_RESOLUTION=100,
        IMAGE_BANDWIDTH=0.2,
        IMAGE_RESOLUTION=20,
        ENTROPY_SUMMARY_DIVERGENCE_P_VALUE=2.0,
        PERSISTENCE_STATISTICS_DIVERGENCE_P_VALUE=2.0,
        WASSERSTEIN_DIVERGENCE_P_VALUE=1.0,
        BETTI_CURVE_DIVERGENCE_P_VALUE=1.0,
        PERSISTENCE_SILHOUETTE_DIVERGENCE_P_VALUE=2.0,
        PERSISTENCE_LIFESPAN_DIVERGENCE_P_VALUE=2.0,
    ) -> None:
        # main data structures managed by the class
        self._time_series = time_series
        self._sublevel_diagram = None
        self._superlevel_diagram = None

        # defaults for vectorisations
        self.ENTROPY_SUMMARY_RESOLUTION = ENTROPY_SUMMARY_RESOLUTION
        self.BETTI_CURVE_RESOLUTION = BETTI_CURVE_RESOLUTION
        self.BETTI_CURVE_NORM_P_VALUE = BETTI_CURVE_NORM_P_VALUE
        self.SILHOUETTE_RESOLUTION = SILHOUETTE_RESOLUTION
        self.SILHOUETTE_WEIGHT = SILHOUETTE_WEIGHT
        self.LIFESPAN_CURVE_RESOLUTION = LIFESPAN_CURVE_RESOLUTION
        self.IMAGE_BANDWIDTH = IMAGE_BANDWIDTH
        self.IMAGE_RESOLUTION = IMAGE_RESOLUTION

        # defaults for divergences
        self.ENTROPY_SUMMARY_DIVERGENCE_P_VALUE = ENTROPY_SUMMARY_DIVERGENCE_P_VALUE
        self.PERSISTENCE_STATISTICS_DIVERGENCE_P_VALUE = (
            PERSISTENCE_STATISTICS_DIVERGENCE_P_VALUE
        )
        self.WASSERSTEIN_DIVERGENCE_P_VALUE = WASSERSTEIN_DIVERGENCE_P_VALUE
        self.BETTI_CURVE_DIVERGENCE_P_VALUE = BETTI_CURVE_DIVERGENCE_P_VALUE
        self.PERSISTENCE_SILHOUETTE_DIVERGENCE_P_VALUE = (
            PERSISTENCE_SILHOUETTE_DIVERGENCE_P_VALUE
        )
        self.PERSISTENCE_LIFESPAN_DIVERGENCE_P_VALUE = (
            PERSISTENCE_LIFESPAN_DIVERGENCE_P_VALUE
        )

    @property
    def sublevel_diagram(self):
        if self._sublevel_diagram is None:
            self._sublevel_diagram = (
                TimeSeriesPersistence._persistence_diagram_from_time_series(
                    self._time_series, superlevel_filtration=False
                )
            )
        if len(self._sublevel_diagram) < 1:
            raise EmptyDiagramException("Sublevel diagram is empty")
        return self._sublevel_diagram

    @property
    def superlevel_diagram(self):
        if self._superlevel_diagram is None:
            self._superlevel_diagram = (
                TimeSeriesPersistence._persistence_diagram_from_time_series(
                    self._time_series, superlevel_filtration=True
                )
            )
        if len(self._superlevel_diagram) < 1:
            raise EmptyDiagramException("Superlevel diagram is empty")
        return self._superlevel_diagram

    @property
    def superlevel_diagram_flipped(self):
        return np.array([[d, b] for b, d in self.superlevel_diagram])

    @staticmethod
    def _sublevel_set_filtration(time_series):
        """
        Helper function. Creates the sublevel set filtration for the given time series.

        Parameters
        ----------
        time_series : array_like
            A list or numpy array of the input time series.

        Returns
        -------
        list
            The filtration: a list of (simplex, value) pairs representing the simplices in the sublevel set filtration.
        """

        filtration = []
        n = len(time_series)

        for i in range(n):
            filtration.append(([i], time_series[i]))

            if i < n - 1:
                edge_value = max(time_series[i], time_series[i + 1])
                filtration.append(([i, i + 1], edge_value))

        return filtration

    @staticmethod
    def _superlevel_set_filtration(time_series):
        """
        Helper function. Creates the superlevel set filtration for the given time series.

        Parameters
        ----------
        time_series : array_like
            A list or numpy array of the input time series.

        Returns
        -------
        list
            The filtration: a list of (simplex, value) pairs representing the superlevel set filtration.

        Notes
        -----
        The values of the simplices are the negations of the original time series values,
        to ensure they are increasing over the filtration.
        """

        # invert the sequence (make peaks into pits and vice versa)
        time_series = -1 * np.array(time_series)

        # apply the sublevel algorithm to the inverted sequence
        return TimeSeriesPersistence._sublevel_set_filtration(time_series)

    @staticmethod
    def _persistent_homology_simplex_tree(filtration):
        """
        Helper function. Construct a Gudhi simplex tree representing the given filtration.

        Parameters
        ----------
        filtration : list
            List of (simplex, value) tuples in the filtration

        Returns
        -------
        gudhi.SimplexTree
            A Gudhi SimplexTree object
        """

        # Create a simplex tree object
        st = gd.SimplexTree()

        # Insert the filtration into the simplex tree
        for simplex, value in filtration:
            st.insert(simplex, value)

        return st

    @staticmethod
    def _persistence_diagram_from_simplex_tree(
        simplex_tree, dimension=0, superlevel_filtration=False
    ):
        """
        Helper function. Construct the persistent homology diagram induced by the given simplex tree.

        Parameters
        ----------
        simplex_tree : a Gudhi SimplexTree object
        dimension : integer, optional
            The dimension of the homology features to be returned.
        superlevel_filtration : Boolean, optional
            Does the simplex tree arise from a superlevel set filtration?
            Default is `False` implying we have a sublevel set simplex tree.

        Returns
        -------
        list
            The persistence diagram: a list of the persistent homology (birth, death) pairs in the given dimension.

        Notes
        -----
        1. When superlevel set adjustment is applied by setting `superlevel_filtration=True`, the intervals returned are (-birth, -death) rather than (birth, death). This is to account for decreasing function values used when building a superlevel set filtration, and the assumption that a simplex tree corresponding to a superlevel set filtration on `f(x)` has been built using the sublevel set filtration of the negated function `-f(x)`. Note that in this situation critical values will satisfy `death<birth`.
        2. The infinite point (corresponding to the global minimum) is removed from the resulting set of points, to ensure downstream functions such as entropy always have finite data to work with.
        """

        if not (dimension >= 0):
            raise ValueError("Requested homology dimension out of range")

        simplex_tree.compute_persistence()
        persistence_diagram = simplex_tree.persistence_intervals_in_dimension(dimension)

        # remove nonfinite points
        persistence_diagram = [
            (b, d)
            for (b, d) in persistence_diagram
            if np.isfinite(b) and np.isfinite(d)
        ]

        # reflip the axes if the filtration was built with superlevels
        if superlevel_filtration:
            persistence_diagram = [(-b, -d) for (b, d) in persistence_diagram]

        # finally create a 2-d numpy array for downstream processing
        persistence_diagram = np.array(persistence_diagram)

        return persistence_diagram

    @staticmethod
    def _persistence_diagram_from_time_series(time_series, superlevel_filtration=False):
        """
        Helper function. Persistence diagram of piecewise linear interpolation of time series.

        Parameters
        ----------
        time_series : array_like
            The discrete time series over which to compute persistent homology.
        superlevel_filtration : boolean, optional
            Is this diagram for a superlevel set filtration? Default: sublevel set filtration.

        Returns
        -------
        array
            List of finite (b,d) pairs in the given diagram.
        """

        filter_function = (
            TimeSeriesPersistence._superlevel_set_filtration
            if superlevel_filtration
            else TimeSeriesPersistence._sublevel_set_filtration
        )
        filtration = filter_function(time_series)
        simplex_tree = TimeSeriesPersistence._persistent_homology_simplex_tree(
            filtration
        )
        persistence_diagram = (
            TimeSeriesPersistence._persistence_diagram_from_simplex_tree(
                simplex_tree, superlevel_filtration=superlevel_filtration
            )
        )
        return persistence_diagram

    ############################################
    ## Vectorisations of persistence diagrams ##
    ############################################

    @property
    def vectorisations(self):
        return dict(
            stats_sub=self.persistence_statistics_vector_sub,
            stats_sup=self.persistence_statistics_vector_sup,
            stats_full=self.persistence_statistics_vector_full,
            entropy_sub=self.entropy_summary_function_sub,
            entropy_sup=self.entropy_summary_function_sup,
            entropy_full=self.entropy_summary_function_full,
            betti_sub=self.betti_curve_function_sub,
            betti_sup=self.betti_curve_function_sup,
            betti_full=self.betti_curve_function_full,
            silhouette_sub=self.persistence_silhouette_function_sub,
            silhouette_sup=self.persistence_silhouette_function_sup,
            silhouette_full=self.persistence_silhouette_function_full,
            lifespan_sub=self.persistence_lifespan_curve_function_sub,
            lifespan_sup=self.persistence_lifespan_curve_function_sup,
            lifespan_full=self.persistence_lifespan_curve_function_full,
            point_summary_sub=self.point_summary_sub,
            point_summary_sup=self.point_summary_sup,
            point_summary_full=self.point_summary_full,
            betti_norm_sub=self.point_summary_betti_norm_sub,
            betti_norm_sup=self.point_summary_betti_norm_sup,
        )

    ## PERSISTENCE STATISTICS VECTOR

    @property
    def persistence_statistics_vector_sub(self):
        return vec.GetPersStats(self.sublevel_diagram)

    @property
    def persistence_statistics_vector_sup(self):
        return vec.GetPersStats(self.superlevel_diagram_flipped)

    @property
    def persistence_statistics_vector_full(self):
        return np.concatenate(
            (
                self.persistence_statistics_vector_sub,
                self.persistence_statistics_vector_sup,
            )
        )

    ## PERSISTENT ENTROPY CURVE

    @property
    def entropy_summary_function_sub(self):
        return vec.GetEntropySummary(
            self.sublevel_diagram, res=self.ENTROPY_SUMMARY_RESOLUTION
        )

    @property
    def entropy_summary_function_sup(self):
        return vec.GetEntropySummary(
            self.superlevel_diagram_flipped, res=self.ENTROPY_SUMMARY_RESOLUTION
        )

    @property
    def entropy_summary_function_full(self):
        return np.concatenate(
            (self.entropy_summary_function_sub, self.entropy_summary_function_sup)
        )

    ## BETTI CURVE

    @property
    def betti_curve_function_sub(self):
        return vec.GetBettiCurveFeature(
            self.sublevel_diagram, res=self.BETTI_CURVE_RESOLUTION
        )

    @property
    def betti_curve_function_sup(self):
        return vec.GetBettiCurveFeature(
            self.superlevel_diagram_flipped, res=self.BETTI_CURVE_RESOLUTION
        )

    @property
    def betti_curve_function_full(self):
        return np.concatenate(
            (self.betti_curve_function_sub, self.betti_curve_function_sup)
        )

    ## PERSISTENCE SILHOUETTE

    @property
    def persistence_silhouette_function_sub(self):
        return vec.GetPersSilhouetteFeature(
            self.sublevel_diagram,
            res=self.SILHOUETTE_RESOLUTION,
            w=self.SILHOUETTE_WEIGHT,
        )

    @property
    def persistence_silhouette_function_sup(self):
        return vec.GetPersSilhouetteFeature(
            self.superlevel_diagram_flipped,
            res=self.SILHOUETTE_RESOLUTION,
            w=self.SILHOUETTE_WEIGHT,
        )

    @property
    def persistence_silhouette_function_full(self):
        return np.concatenate(
            (
                self.persistence_silhouette_function_sub,
                self.persistence_silhouette_function_sup,
            )
        )

    ## PERSISTENCE LIFESPAN CURVE

    @property
    def persistence_lifespan_curve_function_sub(self):
        return vec.GetPersLifespanFeature(
            self.sublevel_diagram, res=self.LIFESPAN_CURVE_RESOLUTION
        )

    @property
    def persistence_lifespan_curve_function_sup(self):
        return vec.GetPersLifespanFeature(
            self.superlevel_diagram_flipped, res=self.LIFESPAN_CURVE_RESOLUTION
        )

    @property
    def persistence_lifespan_curve_function_full(self):
        return np.concatenate(
            (
                self.persistence_lifespan_curve_function_sub,
                self.persistence_lifespan_curve_function_sup,
            )
        )
    
    ## PERSISTENCE POINT SUMMARY
    
    @property
    def point_summary_sub(self):
        return point_summaries([np.array([]), self.sublevel_diagram], np.ones((len(self._time_series), len(self._time_series))))
    
    @property
    def point_summary_sup(self):
        return point_summaries([np.array([]), self.superlevel_diagram_flipped], np.ones((len(self._time_series), len(self._time_series))))

    @property
    def point_summary_full(self):
        return np.concatenate(
            (
                self.point_summary_sub,
                self.point_summary_sup
            )
        )
    
    @property
    def point_summary_betti_norm_sub(self):
        return norm(self.betti_curve_function_sub, ord=self.BETTI_CURVE_NORM_P_VALUE)

    @property
    def point_summary_betti_norm_sup(self):
        return norm(self.betti_curve_function_sup, ord=self.BETTI_CURVE_NORM_P_VALUE)

    ####################################################################
    ## Divergences of super and sub level persistence representations ##
    ####################################################################

    @property
    def divergences(self):
        return dict(
            point_summary_entropy=self.point_summary_entropy_divergence,
            point_summary_max_persistence_ratio=self.point_summary_max_persistence_ratio_divergence,
            point_summary_homology_class_ratio=self.point_summary_homology_class_ratio_divergence,
            entropy=self.entropy_summary_divergence,
            betti=self.betti_curve_divergence,
            silhouette=self.persistence_silhouette_divergence,
            lifespan=self.persistence_lifespan_curve_divergence,
            stats=self.persistence_statistics_divergence,
            entropy_EMD=self.entropy_summary_divergence_emd,
            betti_EMD=self.betti_curve_divergence_emd,
            silhouette_EMD=self.persistence_silhouette_divergence_emd,
            lifespan_EMD=self.persistence_lifespan_curve_divergence_emd,
            stats_EMD=self.persistence_statistics_divergence_emd,
            bottleneck=self.bottleneck_divergence,
            wasserstein=self.wasserstein_divergence,
        )
    
    ## POINT SUMMARY ENTROPY
    @property
    def point_summary_entropy_divergence(self):
        e1 = self.point_summary_sub[1]
        e2 = self.point_summary_sup[1]
        return abs(e1 - e2)
    
    ## POINT SUMMARY MAX PERSISTENCE RATIO
    @property
    def point_summary_max_persistence_ratio_divergence(self):
        e1 = self.point_summary_sub[0]
        e2 = self.point_summary_sup[0]
        return abs(e1 - e2)
    
    ## POINT SUMMARY HOMOLOGY CLASS RATIO
    @property
    def point_summary_homology_class_ratio_divergence(self):
        e1 = self.point_summary_sub[2]
        e2 = self.point_summary_sup[2]
        return abs(e1 - e2)

    ## ENTROPY CURVE
    @property
    def entropy_summary_divergence(self):
        f1 = self.entropy_summary_function_sub
        f2 = self.entropy_summary_function_sup
        return norm(f1 - f2, ord=self.ENTROPY_SUMMARY_DIVERGENCE_P_VALUE)

    @property
    def entropy_summary_divergence_emd(self):
        f1 = self.entropy_summary_function_sub
        f2 = self.entropy_summary_function_sup
        return earth_movers_distance(f1, f2)

    ## BETTI CURVE
    @property
    def betti_curve_divergence(self):
        f1 = self.betti_curve_function_sub
        f2 = self.betti_curve_function_sup
        return norm(f1 - f2, ord=self.BETTI_CURVE_DIVERGENCE_P_VALUE)

    @property
    def betti_curve_divergence_emd(self):
        f1 = self.betti_curve_function_sub
        f2 = self.betti_curve_function_sup
        return earth_movers_distance(f1, f2)

    ## PERSISTENCE SILHOUETTE
    @property
    def persistence_silhouette_divergence(self):
        f1 = self.persistence_silhouette_function_sub
        f2 = self.persistence_silhouette_function_sup
        return norm(f1 - f2, ord=self.PERSISTENCE_SILHOUETTE_DIVERGENCE_P_VALUE)

    @property
    def persistence_silhouette_divergence_emd(self):
        f1 = self.persistence_silhouette_function_sub
        f2 = self.persistence_silhouette_function_sup
        return earth_movers_distance(f1, f2)

    ## PERSISTENCE LIFESPAN
    @property
    def persistence_lifespan_curve_divergence(self):
        f1 = self.persistence_lifespan_curve_function_sub
        f2 = self.persistence_lifespan_curve_function_sup
        return norm(f1 - f2, ord=self.PERSISTENCE_LIFESPAN_DIVERGENCE_P_VALUE)

    @property
    def persistence_lifespan_curve_divergence_emd(self):
        f1 = self.persistence_lifespan_curve_function_sub
        f2 = self.persistence_lifespan_curve_function_sup
        return earth_movers_distance(f1, f2)

    ## STATISTICS
    @property
    def persistence_statistics_divergence(self):
        v1 = self.persistence_statistics_vector_sub
        v2 = self.persistence_statistics_vector_sup
        return norm(v1 - v2, ord=self.PERSISTENCE_STATISTICS_DIVERGENCE_P_VALUE)

    @property
    def persistence_statistics_divergence_emd(self):
        v1 = self.persistence_statistics_vector_sub
        v2 = self.persistence_statistics_vector_sup
        return earth_movers_distance(v1, v2)

    ## BOTTLENECK
    @property
    def bottleneck_divergence(self):
        return bottleneck_distance(
            self.sublevel_diagram, self.superlevel_diagram_flipped
        )

    ## WASSERSTEIN
    @property
    def wasserstein_divergence(self):
        return wasserstein_distance(
            self.sublevel_diagram,
            self.superlevel_diagram_flipped,
            order=self.WASSERSTEIN_DIVERGENCE_P_VALUE,
        )
